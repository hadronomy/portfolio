---
import { Icon } from 'astro-icon/components';

interface Skill {
  name: string;
  icon: string;
}

interface Props {
  skills: Skill[];
  emptySlots?: number; // Optional number of empty slots to fill the grid
}

const { skills, emptySlots = 16 } = Astro.props;
---

<div class="grid-container relative">
  <div class="grid grid-cols-3 md:grid-cols-6 lg:grid-cols-8 gap-4 w-full p-4 mt-4 rounded-2xl">
    {
      skills.map((skill) => (
        <div class="card-wrapper bg-muted">
          <div class="card-content">
            <Icon name={skill.icon} class="h-full w-full p-2" />
          </div>
        </div>
      ))
    }
    {
      // Add empty slots to fill the grid
      Array(emptySlots).fill(0).map(() => (
        <div class="card-wrapper">
          <div class="card-content"></div>
        </div>
      ))
    }
  </div>
</div>

<style>
  @property --rotate {
    syntax: "<angle>";
    initial-value: 132deg;
    inherits: false;
  }

  :global(:root) {
    --mouse-x: 50%;
    --mouse-y: 50%;
    --color-primary: 181 239 255;    /* #b5efff */
    --color-secondary: 117 143 217;  /* #758fd9 */
    --color-tertiary: 117 143 217;     /* #9d86bf */
    --border-width: 2px;
    --card-opacity: 0;
  }

  .grid-container {
    position: relative;
    overflow: hidden;
  }

  .card-wrapper {
    position: relative;
    width: 5rem;
    height: 5rem;
    border-radius: 1rem;
    overflow: hidden;
    z-index: 1;
    background-color: hsl(var(--muted-foreground) / 0.3);
  }

  .card-wrapper::before {
    content: "";
    position: absolute;
    width: 300px;
    height: 300px;
    background: linear-gradient(
      var(--rotate),
      rgb(var(--color-primary)), 
      rgb(var(--color-secondary)) 43%, 
      rgb(var(--color-tertiary))
    );
    border-radius: 50%;
    filter: blur(60px);
    opacity: var(--card-opacity);
    z-index: 0;
    transition: opacity 0.3s ease;
    animation: spin 3s linear infinite;
    /* Position based on relative coordinates within each card */
    left: calc(var(--x-pos, 0) * 1%);
    top: calc(var(--y-pos, 0) * 1%);
    transform: translate(-50%, -50%);
  }

  .card-content {
    position: absolute;
    inset: var(--border-width);
    background-color: hsl(var(--muted));
    border-radius: calc(1rem - var(--border-width));
    z-index: 2;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .grid-container:hover .card-wrapper::before {
    opacity: var(--card-opacity);
  }

  @keyframes spin {
    0% {
      --rotate: 0deg;
    }
    100% {
      --rotate: 360deg;
    }
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const gridContainer = document.querySelector('.grid-container') as HTMLElement;
    const cards = document.querySelectorAll('.card-wrapper') as NodeListOf<HTMLElement>;
    
    if (gridContainer) {
      // Set mouse position variables
      document.addEventListener('mousemove', (e) => {
        const mouseEvent = e as MouseEvent;
        
        // Calculate position for each card
        cards.forEach(card => {
          const rect = card.getBoundingClientRect();
          
          // Calculate the position of the mouse relative to the card (as a percentage)
          const relativeX = ((mouseEvent.clientX - rect.left) / rect.width) * 100;
          const relativeY = ((mouseEvent.clientY - rect.top) / rect.height) * 100;
          
          // Set the custom properties on each card
          card.style.setProperty('--x-pos', `${relativeX}`);
          card.style.setProperty('--y-pos', `${relativeY}`);
        });
      });
      
      // Handle mouse enter/leave for container
      gridContainer.addEventListener('mouseleave', () => {
        document.documentElement.style.setProperty('--card-opacity', '0');
      });
      
      gridContainer.addEventListener('mouseenter', () => {
        document.documentElement.style.setProperty('--card-opacity', '1');
      });
    }
  });
</script>
